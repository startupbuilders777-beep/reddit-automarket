// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          UserRole  @default(USER)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  
  // Data relationships
  dataSources   DataSource[]
  documents     Document[]
  conversations Conversation[]
  apiKeys       ApiKey[]
  usageRecords  UsageRecord[]
  webhooks      Webhook[]
}

enum UserRole {
  USER
  ADMIN
  BILLING_ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// DATA SOURCES
// ============================================

model DataSource {
  id          String        @id @default(cuid())
  name        String
  type        DataSourceType
  status      DataSourceStatus @default(PENDING)
  config      Json?        // Encrypted config for credentials
  metadata    Json?
  
  // Limits
  maxDocuments Int?        @default(10000)
  maxSizeMb   Int?        @default(100) // 100MB default
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  lastSyncAt  DateTime?
  
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  documents   Document[]
  connectors  Connector[]

  @@index([userId])
  @@index([type])
  @@index([status])
}

enum DataSourceType {
  FILE_UPLOAD
  GOOGLE_DRIVE
  DROPBOX
  S3
  HUBSPOT
  SALESFORCE
  POSTGRESQL
  MONGODB
  WEBSITE
  API
  SLACK
  DISCORD
  NOTION
  CONFLUENCE
  EMAIL
  AUDIO
}

enum DataSourceStatus {
  PENDING
  CONNECTING
  CONNECTED
  SYNCING
  ERROR
  DISCONNECTED
}

// ============================================
// DOCUMENTS & CHUNKS
// ============================================

model Document {
  id            String        @id @default(cuid())
  name          String
  type          String        // MIME type
  size          Int           // bytes
  status        DocumentStatus @default(PENDING)
  
  // Content
  content       String?       @db.Text
  metadata      Json?
  
  // Processing
  chunkingStrategy ChunkingStrategy @default(PARAGRAPH)
  embeddingModel  String?       @default("text-embedding-3-small")
  embeddingStatus EmbeddingStatus @default(PENDING)
  chunksCount    Int?          @default(0)
  
  // Quality
  qualityScore  Float?         // 0-100
  isDuplicate   Boolean        @default(false)
  
  // Versioning
  version       Int            @default(1)
  parentId      String?
  
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  processedAt   DateTime?
  
  sourceId      String
  source        DataSource     @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  
  userId        String
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  chunks        Chunk[]
  
  @@index([sourceId])
  @@index([userId])
  @@index([status])
  @@index([embeddingStatus])
}

enum DocumentStatus {
  PENDING
  UPLOADING
  PROCESSING
  COMPLETED
  FAILED
  DELETED
}

enum ChunkingStrategy {
  PARAGRAPH
  SENTENCE
  SEMANTIC
  FIXED_SIZE
  PAGE
}

enum EmbeddingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model Chunk {
  id            String      @id @default(cuid())
  content       String      @db.Text
  embedding     Unsupported("vector(1536)")? // Vector embedding
  metadata      Json?
  
  // Position
  chunkIndex    Int
  startChar     Int?
  endChar       Int?
  
  // Quality
  qualityScore  Float?
  
  createdAt     DateTime    @default(now())
  
  documentId    String
  document      Document    @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@index([documentId])
}

// ============================================
// VECTOR STORAGE
// ============================================

model VectorStore {
  id            String      @id @default(cuid())
  name          String
  provider      VectorProvider
  config        Json        // Connection config
  
  dimension     Int         @default(1536)
  
  // Limits
  maxVectors    Int?        @default(1000000)
  currentVectors Int        @default(0)
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  userId        String
  
  @@index([userId])
}

enum VectorProvider {
  INTERNAL  // Using pgvector
  PINECONE
  WEAVIATE
  QDRANT
  CHROMA
}

// ============================================
// CONNECTORS (External Integrations)
// ============================================

model Connector {
  id            String          @id @default(cuid())
  name          String
  type          ConnectorType
  status        ConnectorStatus @default(DISABLED)
  config        Json?
  
  // Sync settings
  syncEnabled   Boolean         @default(false)
  syncInterval  Int?            // minutes
  lastSyncAt    DateTime?
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  sourceId      String
  source        DataSource      @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  
  @@index([sourceId])
}

enum ConnectorType {
  WEBHOOK
  REST_API
  GRAPHQL
  S3_BUCKET
  FTP
  SFTP
}

enum ConnectorStatus {
  ENABLED
  DISABLED
  ERROR
}

// ============================================
// CONVERSATIONS & MESSAGES (Chat/RAG)
// ============================================

model Conversation {
  id            String          @id @default(cuid())
  title         String?
  model         String?         // AI model used
  systemPrompt  String?         @db.Text
  
  // RAG settings
  useRag        Boolean         @default(true)
  temperature   Float?          @default(0.7)
  maxTokens     Int?            @default(2048)
  
  // Sources
  sources       String[]        // DataSource IDs
  
  // Stats
  messagesCount Int             @default(0)
  tokensUsed     Int             @default(0)
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  userId        String
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  messages      Message[]
  
  @@index([userId])
}

model Message {
  id            String        @id @default(cuid())
  role          MessageRole
  content       String        @db.Text
  
  // For streaming
  isComplete    Boolean       @default(false)
  
  // Citations
  citations     Json?         // Array of {chunkId, documentId, score}
  
  // Tokens
  tokens        Int?          
  model         String?
  
  createdAt     DateTime      @default(now())
  
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@index([conversationId])
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

// ============================================
// API KEYS
// ============================================

model ApiKey {
  id            String      @id @default(cuid())
  name          String
  key           String      @unique @default(cuid())
  prefix        String      // First 8 chars for display
  
  // Limits
  rateLimit     Int?        // requests per minute
  dailyLimit    Int?        // requests per day
  
  // Usage
  requestsUsed  Int          @default(0)
  lastUsedAt    DateTime?
  
  // Status
  isActive      Boolean     @default(true)
  expiresAt     DateTime?
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  userId        String
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  usageRecords  UsageRecord[]
  
  @@index([userId])
  @@index([key])
}

// ============================================
// USAGE & ANALYTICS
// ============================================

model UsageRecord {
  id            String        @id @default(cuid())
  
  // Metrics
  tokensUsed    Int           @default(0)
  tokensInput   Int           @default(0)
  tokensOutput  Int           @default(0)
  requests      Int           @default(1)
  
  // Costs
  cost          Float         @default(0)
  currency      String        @default("USD")
  
  // Details
  model         String
  operation     String?       // chat, embedding, rag, etc.
  
  metadata      Json?
  
  createdAt     DateTime      @default(now())
  
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  apiKeyId      String?
  apiKey        ApiKey?       @relation(fields: [apiKeyId], references: [id], onDelete: SetNull)
  
  @@index([userId, createdAt])
  @@index([apiKeyId])
  @@index([model])
}

// ============================================
// WEBHOOKS
// ============================================

model Webhook {
  id            String        @id @default(cuid())
  name          String
  url           String
  events        String[]      // Event types to trigger
  
  // Auth
  secret        String?
  
  // Status
  isActive      Boolean       @default(true)
  
  // Logs
  lastTriggered DateTime?
  failureCount  Int           @default(0)
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

// ============================================
// JOBS & PROCESSING QUEUE
// ============================================

model Job {
  id            String      @id @default(cuid())
  type          JobType
  status        JobStatus   @default(QUEUED)
  
  // Data
  payload       Json
  result        Json?
  error         String?     @db.Text
  
  // Progress
  progress      Int         @default(0) // 0-100
  attempts      Int         @default(0)
  maxAttempts   Int         @default(3)
  
  // Timing
  startedAt     DateTime?
  completedAt   DateTime?
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  scheduledFor  DateTime?   // For delayed jobs
  
  @@index([status])
  @@index([type, status])
  @@index([createdAt])
}

enum JobType {
  EMBEDDING_GENERATION
  FILE_PROCESSING
  DATA_SYNC
  RAG_QUERY
  EXPORT
  WEBHOOK_TRIGGER
}

enum JobStatus {
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}
